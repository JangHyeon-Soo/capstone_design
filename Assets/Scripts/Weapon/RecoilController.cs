
using UnityEngine;
using System.Collections;

public class RecoilController : MonoBehaviour
{
    public PlayerController Owner;
    public Transform ikTarget;         // 오른손 IK 타겟 (카메라 자식)
    public Vector3 recoilOffset; // 반동: 위 + 뒤로
    public Quaternion rotationOffset;
    public float recoilDuration = 0.5f;
    public float returnDuration = 0.1f;

    private Vector3 originalLocalPosition;

    public Rigidbody[] spineRigidbodies; // Spine1 ~ Spine5
    public float recoilAmount = 5f;
    public float recoilSpeed = 5f;

    
    // 카메라 기준에서 IK 타겟이 벗어날 수 있는 최대 거리
    public float maxRecoilDistance = 0.15f;
    
    [HideInInspector]public bool isRecoiling;


    //public float recoilAmount = 5f;
    public float frequency = 20f;
    public float damping = 6f;
    //public float recoilDuration = 0.5f;

    private float recoilTime = 0f;
    private Quaternion originalRot;
    public void Start()
    {
        if(gameObject.tag == "Player")
        {
            Owner = GetComponentInParent<PlayerController>();
        }
    }
    public void ApplyRecoil()
    {
        if (ikTarget == null) return;
        else if (isRecoiling) return;

        // 머즐 플래시
        transform.GetComponent<WeaponScript>().FireEffect(); 

        //카메라 흔들기
        Owner.GetComponent<PlayerController>().playerCamera.GetComponent<CamController>().StartCameraShake(0.1f, 0.001f, 2f); // 1초, 강도 0.2, 빈도 2

        isRecoiling = true;
        recoilTime = 0;


        //반동 
        StopAllCoroutines();
        StartCoroutine(DoRecoil());
    }

    private void Update()
    {
        if (gameObject.tag != "Player") return;

        SetIKTarget();
    }

    private IEnumerator DoRecoil()
    {
        if (ikTarget == null) yield break;

        isRecoiling = true;

        Vector3 originalPos = ikTarget.localPosition;
        Quaternion originalRot = ikTarget.localRotation;

        // 리코일 방향 (총구 방향)
        Vector3 recoilDir = transform.GetComponent<WeaponScript>().FirePoint.forward.normalized;

        // 리코일 위치 오프셋 (뒤로)
        Vector3 posOffset = recoilDir * Random.Range(-0.03f, -0.07f);
        Vector3 targetPos = originalPos + posOffset;

        float recoilDuration = 0.04f;
        float returnDuration = 0.04f;

        float time = 0f;

        // 반동 튐 (빠르게)
        while (time < recoilDuration)
        {
            float t = time / recoilDuration;
            ikTarget.localPosition = Vector3.Lerp(originalPos, targetPos, t);
            time += Time.deltaTime;
            yield return null;
        }

        // 원위치 복귀 + 감쇠 진동 회전
        time = 0f;
        while (time < returnDuration)
        {
            float t = time / returnDuration;

            // 기본 복귀 위치
            Vector3 currentPos = Vector3.Lerp(targetPos, originalPos, t);

            // 위치 복귀
            ikTarget.localPosition = currentPos;

            time += Time.deltaTime;
            yield return null;
        }

        isRecoiling = false;
    }

    public void SetIKTarget()
    {
        PlayerController pc = GetComponentInParent<PlayerController>();
        if (pc != null)
        {
            switch (pc.armState)
            {
                case GameManager.armState.Unarmed:
                    ikTarget = null;
                    break;

                case GameManager.armState.Pistol:
                    ikTarget = pc.GetComponent<HandIKController>().RHT;
                    break;

                case GameManager.armState.Rifle:
                    ikTarget = pc.GetComponent<HandIKController>().RHT;
                    break;
            }
        }
    }
}


